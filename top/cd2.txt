prefix to postfix 

# Write Python3 code here
# -- coding: utf-8 --

# Example Input
s = "*-A/BC-/AKL"

# Stack for storing operands
stack = []

operators = set(['+', '-', '*', '/', '^'])

# Reversing the order
s = s[::-1]

# iterating through individual tokens
for i in s:

	# if token is operator
	if i in operators:

		# pop 2 elements from stack
		a = stack.pop()
		b = stack.pop()

		# concatenate them as operand1 +
		# operand2 + operator
		temp = a+b+i
		stack.append(temp)

	# else if operand
	else:
		stack.append(i)

# printing final output
print(*stack)














recursive descent 
print("Recursive Desent Parsing For following grammar\n")
print("E->TE'\nE'->+TE'/@\nT->FT'\nT'->*FT'/@\nF->(E)/i\n")
print("Enter the string want to be checked\n")
global s
s=list(input())
global i
i=0
def match(a):
    global s
    global i
    if(i>=len(s)):
        return False
    elif(s[i]==a):
        i+=1
        return True
    else:
        return False
def F():
    if(match("(")):
        if(E()):
            if(match(")")):
                return True
            else:
                return False
        else:
            return False
    elif(match("i")):
        return True
    else:
        return False
def Tx():
    if(match("*")):
        if(F()):
            if(Tx()):
                return True
            else:
                return False
        else:
            return False
    else:
        return True
def T():
    if(F()):
        if(Tx()):
            return True
        else:
            return False
    else:
        return False
def Ex():
    if(match("+")):
        if(T()):
            if(Ex()):
                return True
            else:
                return False
        else:
            return False
    else:
        return True
def E():
    if(T()):
        if(Ex()):
            return True
        else:
            return False
    else:
        return False
if(E()):
    if(i==len(s)):
        print("String is accepted")
    else:
         print("String is not accepted")
    
else:
    print("string is not accepted")




























%{
#include <stdio.h>
%}

%%
[0-9]+ {
    int num = atoi(yytext);
    if (num % 2 == 0) {
        printf("%d is even\n", num);
    } else {
        printf("%d is odd\n", num);
    }
}
%%

int yywrap() {return 1;}
int main() {
    yylex();
    return 0;
}


















public class Armstrong {

    public static void main(String[] args) {

        int number = 371, originalNumber, remainder, result = 0;

        originalNumber = number;

        while (originalNumber != 0)
        {
            remainder = originalNumber % 10;
            result += Math.pow(remainder, 3);
            originalNumber /= 10;
        }

        if(result == number)
            System.out.println(number + " is an Armstrong number.");
        else
            System.out.println(number + " is not an Armstrong number.");
    }
}









public class Main {
    public static void main(String[] args) {
        int number = 371; // Change the number here
        if (isArmstrong(number)) {
            System.out.println(number + " is an Armstrong number.");
        } else {
            System.out.println(number + " is not an Armstrong number.");
        }
    }

    // Function to check if a number is an Armstrong number
    static boolean isArmstrong(int number) {
        int originalNumber = number;
        int numDigits = countDigits(number);
        int sum = 0;
        while (number > 0) {
            int digit = number % 10;
            sum += Math.pow(digit, numDigits);
            number /= 10;
        }
        return sum == originalNumber;
    }

    // Function to count the number of digits in a number
    static int countDigits(int number) {
        int count = 0;
        while (number != 0) {
            number /= 10;
            count++;
        }
        return count;
    }
}












public class Main {
    public static void main(String[] args) {
        int n = 10; // Number of terms in the Fibonacci series
        System.out.println("Fibonacci series of " + n + " terms:");
        int prev = 0, curr = 1;
        for (int i = 1; i <= n; ++i) {
            System.out.print(prev + " ");
            int sum = prev + curr;
            prev = curr;
            curr = sum;
        }
    }
}















%{
#include "y.tab.h"
%}

%%
[0-9]+      { yylval = atoi(yytext); return NUMBER; }
[-+*/()\n]  { return *yytext; }
[ \t]       ; /* skip whitespace */

%%

int yywrap() {
    return 1;
}


%{
#include <stdio.h>
#include <stdlib.h>
%}

%token NUMBER
%left '+' '-'
%left '*' '/'

%%

calc: expr { printf("Result: %d\n", $1); }
    ;

expr: expr '+' expr { $$ = $1 + $3; }
    | expr '-' expr { $$ = $1 - $3; }
    | expr '*' expr { $$ = $1 * $3; }
    | expr '/' expr { $$ = $1 / $3; }
    | '(' expr ')'  { $$ = $2; }
    | NUMBER        { $$ = $1; }
    ;

%%

int yyerror(const char *msg) {
    return 1;
}

int main() {
    yyparse();
    return 0;
}
calc.y above

flex calc.l
bison -dy calc.y
gcc lex.yy.c y.tab.c -o file
./file














class Parser:
    def _init_(self, expression):
        self.expression = expression
        self.pos = 0

    def parse_expression(self):
        code = self.parse_term()
        while self.pos < len(self.expression):
            if self.expression[self.pos] == '+':
                self.pos += 1
                term_code = self.parse_term()
                code += f" + {term_code}"
            elif self.expression[self.pos] == '-':
                self.pos += 1
                term_code = self.parse_term()
                code += f" - {term_code}"
            else:
                raise SyntaxError("Invalid operator")
        return code

    def parse_term(self):
        factor_code = self.parse_factor()
        while self.pos < len(self.expression):
            if self.expression[self.pos] == '*':
                self.pos += 1
                factor_code2 = self.parse_factor()
                factor_code += f" * {factor_code2}"
            elif self.expression[self.pos] == '/':
                self.pos += 1
                factor_code2 = self.parse_factor()
                factor_code += f" / {factor_code2}"
            else:
                break
        return factor_code

    def parse_factor(self):
        if self.expression[self.pos].isdigit():
            num = ""
            while self.pos < len(self.expression) and self.expression[self.pos].isdigit():
                num += self.expression[self.pos]
                self.pos += 1
            return num
        elif self.expression[self.pos] == '(':
            self.pos += 1
            code = self.parse_expression()
            if self.expression[self.pos] != ')':
                raise SyntaxError("Expected closing parenthesis")
            self.pos += 1
            return code
        else:
            raise SyntaxError("Invalid factor")


def generate_intermediate_code(expression):
    parser = Parser(expression)
    return parser.parse_expression()


if _name_ == "_main_":
    expression = input("Enter an arithmetic expression: ")
    try:
        intermediate_code = generate_intermediate_code(expression)
        print("Intermediate code:", intermediate_code)
    except SyntaxError as e:
        print("Syntax error:", e)
















def infix_to_postfix(expression):
  prec, stack, postfix = {'+':1,'-':1,'*':2,'/':2,'^':3}, [], ''
    
  for char in expression:
    if char.isalnum(): postfix += char
    else: 
      while stack and prec.get(stack[-1],0) >= prec[char]:
          postfix += stack.pop()
      stack.append(char)
  return postfix 

# Example usage
infix_expression = "a+b*c^d-e^f+g*h-i"
print("Postfix Expression:", infix_to_postfix(infix_expression))



